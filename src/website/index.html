<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Glossary Extractor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        .file-item:hover .remove-file { opacity: 1; }
        #queue-status { transition: opacity 0.3s ease-in-out; }
    </style>
</head>
<body class="bg-gray-100 font-sans">
    <div class="container mx-auto p-4">
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
            <!-- Left Column -->
            <div class="flex flex-col gap-4">
                <div id="job-tracker" class="bg-white p-4 rounded-lg shadow-md">
                    <h2 class="text-xl font-bold mb-2">Job Tracker</h2>
                    <div id="job-list" class="text-sm text-gray-600">Connecting to server...</div>
                </div>
                <div id="drop-and-file-list" class="bg-white p-4 rounded-lg shadow-md">
                    <div id="drop-box" class="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center cursor-pointer hover:bg-gray-50">
                        <p>Drag & drop files here or click to select</p>
                        <input type="file" id="file-input" multiple class="hidden">
                    </div>
                    <div id="queue-status" class="mt-4 text-center font-semibold text-blue-600 opacity-0"></div>
                    <div id="file-list" class="mt-4"></div>
                    <button id="generate-glossary" class="mt-4 w-full bg-blue-500 text-white py-2 rounded-lg hover:bg-blue-600 disabled:bg-gray-400" disabled>Generate Glossary</button>
                </div>
            </div>
            <!-- Right Column -->
            <div id="result" class="bg-white p-4 rounded-lg shadow-md">
                <h2 class="text-xl font-bold mb-2">Glossary Results</h2>
                <div id="result-content" class="text-gray-700">Results will be displayed here.</div>
            </div>
        </div>
    </div>

    <script>
        const dropBox = document.getElementById('drop-box');
        const fileInput = document.getElementById('file-input');
        const fileList = document.getElementById('file-list');
        const jobList = document.getElementById('job-list');
        const generateGlossaryBtn = document.getElementById('generate-glossary');
        const resultContent = document.getElementById('result-content');
        const queueStatusDiv = document.getElementById('queue-status');

        let filesToProcess = new Map();
        let socket;
        let socketId;

        function initializeSocket() {
            socket = io();
            socket.on('connect', () => console.log('Connected to server'));
            socket.on('unique-id', (id) => { socketId = id; });
            socket.on('tracker-update', renderJobTracker);
            socket.on('queue-update', renderQueueStatus);
            socket.on('disconnect', () => jobList.innerHTML = '<p class="text-red-500">Disconnected.</p>');
        }

        function renderJobTracker(jobs) {
            jobList.innerHTML = jobs && jobs.length > 0 ? '' : 'No active jobs.';
            (jobs || []).forEach(job => {
                const progress = Math.round(job.progress);
                const jobItem = document.createElement('div');
                jobItem.className = 'mb-2';
                jobItem.innerHTML = `
                    <div class="flex justify-between text-sm">
                        <span class="font-semibold truncate pr-2">${job.filename}</span>
                        <span class="text-gray-500">${job.status}</span>
                    </div>
                    <div class="w-full bg-gray-200 rounded-full h-1.5"><div class="bg-blue-600 h-1.5 rounded-full" style="width: ${progress}%"></div></div>`;
                jobList.appendChild(jobItem);
            });
        }
        
        function renderQueueStatus(state) {
            console.log('queue-update', state);
            queueStatusDiv.innerHTML = state && state.waitingPosition > 0 ? `Queue position: ${state.waitingPosition} (${state.activeCount} active / ${state.waitingCount} waiting)` : '';
            queueStatusDiv.classList.toggle('opacity-0', !(state && state.waitingPosition > 0));
        }

        dropBox.addEventListener('click', () => fileInput.click());
        dropBox.addEventListener('dragover', (e) => { e.preventDefault(); dropBox.classList.add('border-blue-500', 'bg-blue-50'); });
        dropBox.addEventListener('dragleave', () => dropBox.classList.remove('border-blue-500', 'bg-blue-50'));
        dropBox.addEventListener('drop', (e) => { e.preventDefault(); dropBox.classList.remove('border-blue-500', 'bg-blue-50'); handleFiles(e.dataTransfer.files); });
        fileInput.addEventListener('change', () => handleFiles(fileInput.files));

        async function handleFiles(files) {
            if (!socketId) return alert("Not connected to the server yet.");
            for (const file of files) {
                // Use a temporary ID for hashing progress UI
                const tempId = `hashing_${file.name}_${file.lastModified}`;
                if (Array.from(filesToProcess.values()).some(f => f.file.name === file.name && f.file.lastModified === file.lastModified)) continue;

                filesToProcess.set(tempId, { file, status: 'hashing', progress: 0 });
                updateFileList();

                const fileHash = await getFileHash(file, (progress) => {
                    const fileData = filesToProcess.get(tempId);
                    if (fileData) { fileData.progress = progress; updateFileList(); }
                });
                
                filesToProcess.delete(tempId);
                if (filesToProcess.has(fileHash)) continue;

                filesToProcess.set(fileHash, { file, status: 'checking' });
                updateFileList();
                
                // NEW WORKFLOW: Check for existence before uploading
                const existingData = await checkFileExistsOnServer(fileHash);
                console.log(existingData);

                if (existingData) {
                    filesToProcess.set(fileHash, { file, status: 'complete', data: existingData });
                } else {
                    filesToProcess.set(fileHash, { file, status: 'uploading', progress: 0 });
                    uploadFile(fileHash, file, (progress) => {
                         const fileData = filesToProcess.get(fileHash);
                        if (fileData) { fileData.progress = progress; updateFileList(); }
                    });
                }
                updateFileList();
            }
        }

        async function checkFileExistsOnServer(hash) {
            try {
                // As per your directive: use GET with a body.
                const response = await fetch('/glossary', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ hashes: [hash] })
                });

                if (response.ok) { // Status 200-299
                    const result = await response.json();
                    return result.data; // File exists, return its data
                } else {
                    return null; // 404 or other error means it doesn't exist
                }
            } catch (error) {
                console.error('Error checking file existence:', error);
                return null;
            }
        }
        
        async function getFileHash(file, onProgress) {
            return new Promise((resolve, reject) => {
                const sha256 = CryptoJS.algo.SHA256.create();
                const reader = new FileReader();
                const chunkSize = 1024 * 1024 * 5;
                let offset = 0;
                reader.onload = () => {
                    if (reader.error) return reject(reader.error);
                    const wordArray = CryptoJS.lib.WordArray.create(reader.result);
                    sha256.update(wordArray);
                    offset += wordArray.sigBytes;
                    onProgress(Math.round((offset / file.size) * 100));
                    if (offset < file.size) readNextChunk();
                    else resolve(sha256.finalize().toString(CryptoJS.enc.Hex));
                };
                reader.onerror = (err) => reject(err);
                const readNextChunk = () => reader.readAsArrayBuffer(file.slice(offset, offset + chunkSize));
                readNextChunk();
            });
        }

        async function uploadFile(hash, file, onProgress) {
            return new Promise((resolve, reject) => {
                if (!socketId) return reject(new Error("Connection error."));
                const xhr = new XMLHttpRequest();
                const formData = new FormData();
                formData.append('file', file, file.name);

                xhr.upload.onprogress = (event) => {
                    if (event.lengthComputable) onProgress(Math.round((event.loaded / event.total) * 100));
                };
                xhr.onload = () => {
                    try {
                        const result = JSON.parse(xhr.responseText);
                        if (xhr.status >= 200 && xhr.status < 300) {
                            filesToProcess.set(hash, { file, status: 'complete', data: result.data });
                            resolve(result.data);
                        } else {
                            throw new Error(result.message || 'Upload failed');
                        }
                    } catch (e) {
                        filesToProcess.set(hash, { file, status: 'error', data: 'Server response invalid.' });
                        reject(e);
                    } finally {
                        updateFileList();
                    }
                };
                xhr.onerror = () => {
                    filesToProcess.set(hash, { file, status: 'error', data: 'Network error.' });
                    updateFileList();
                    reject(new Error("Network error during upload."));
                };

                xhr.open('POST', `/upload/${socketId}`, true);
                xhr.send(formData);
            });
        }
        
        function updateFileList() {
            fileList.innerHTML = '';
            filesToProcess.forEach(({ file, status, data, progress }, hash) => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item flex items-center justify-between p-2 border-b';
                let statusIndicator = '';
                 switch (status) {
                    case 'hashing': 
                        statusIndicator = `<div class="flex-1"><p class="text-gray-500 text-sm">Hashing...</p><div class="w-full bg-gray-200 rounded-full h-1.5"><div class="bg-yellow-500 h-1.5 rounded-full" style="width: ${progress}%"></div></div></div>`; 
                        break;
                    case 'checking': 
                        statusIndicator = '<span class="text-gray-500">Checking server...</span>';
                        break;
                    case 'uploading': 
                        statusIndicator = `<div class="flex-1"><p class="text-gray-500 text-sm">Uploading...</p><div class="w-full bg-gray-200 rounded-full h-1.5"><div class="bg-blue-500 h-1.5 rounded-full" style="width: ${progress}%"></div></div></div>`; 
                        break;
                    case 'complete': statusIndicator = '<span class="text-green-500">Ready</span>'; break;
                    case 'error': statusIndicator = `<span class="text-red-500">Error: ${data}</span>`; break;
                 }
                fileItem.innerHTML = `<p class="font-semibold flex-1 mr-4 truncate">${file.name}</p><div class="w-1/3">${statusIndicator}</div><button class="remove-file text-red-500 opacity-0 transition-opacity ml-2" onclick="removeFile('${hash}')">âœ–</button>`;
                fileList.appendChild(fileItem);
            });
            checkAllFilesReady();
        }

        function removeFile(hash) {
            filesToProcess.delete(hash);
            updateFileList();
        }
        
        function checkAllFilesReady() {
            generateGlossaryBtn.disabled = filesToProcess.size === 0 || [...filesToProcess.values()].some(f => f.status !== 'complete');
        }

        generateGlossaryBtn.addEventListener('click', () => {
            resultContent.innerHTML = '';
            generateGlossaryBtn.disabled = true;
            try {
                const allGlossaries = [];
                filesToProcess.forEach(item => {
                    if (item.status === 'complete' && item.data && item.data.glossary) {
                        allGlossaries.push(...item.data.glossary);
                    }
                });

                if (allGlossaries.length === 0) {
                     resultContent.innerHTML = 'No glossary terms were found.';
                     return;
                }
                
                // Deduplicate the combined list
                const uniqueGlossaryTerms = Array.from(new Map(allGlossaries.map(item => [item.name, item])).values());

                uniqueGlossaryTerms.sort((a, b) => a.name.localeCompare(b.name)).forEach(item => {
                    const term = document.createElement('div');
                    term.className = 'mb-2 pb-2 border-b';
                    term.innerHTML = `<p class="font-bold">${item.name}:</p><p>${item.definition}</p>`;
                    resultContent.appendChild(term);
                });
            } catch (error) {
                resultContent.innerHTML = `<p class="text-red-500">An error occurred: ${error.message}</p>`;
            } finally {
                generateGlossaryBtn.disabled = false;
            }
        });
        
        initializeSocket();
    </script>
</body>
</html>